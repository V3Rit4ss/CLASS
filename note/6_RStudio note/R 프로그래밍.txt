1. R 프로그래밍

[ 1 ] if ~ else 문장.
if 구문은 조건식을 이용해 단독으로 사용될 수 있다. 경우에 따라 else if 블록을 이용해 추가 조건식을 정할 수 있으며,
if블록 또는 else if 블록에서 만족하는 조건식을 찾기 못할 때 실행되는 else 블록을 가질 수 있다.

if (조건식1) {
   조건식1 이 참일 경우
} else if(조건식2) {
   조건식2 가 참일 경우 실행, else if 블록 생략 가능
} else {
  모든 조건식이 거짓일 경우 실행, else 블록 생략 가능.
}

한마디로 자바에서 쓰이던 if ~ else 문 을 그대로 쓰면된다.

ifelse() 나중에


[ 2 ]switch( ) 함수도 자바에서 쓰이던 문법 그대로 쓰면 된다.


[ 3 ] for 반복문 : for-in 문 과 비슷하다.

x <- c(-2,5,4,8)
for(val in x) {
  cat(val,'\t')  
}

#10회 반복.
for(val in 1:10){
  cat(val, '안녕하세요')
}

[ 4 ] while문. = 조건이 참이면 반복.  => 자바에서 쓰이던 문법 그대로 쓰면 된다.
i <- 1
while(i<6){
  print(i)
  i= i+1
}

[ 5 ] repeat : 반복
i <- 1
repeat{
  if(i>6)
    break;    => 반복문들은 중단을 할 것을 넣어야한다.
  print(i)
  i <- i +1
}

[ 6 ] 탈출문 - break, next
break 는 반복문을 완전히 빠져 나온다.
next 는 반복문에서 아무것도 하지않고 다음 반복으로 건너뛴다.


2. 연산자.
산술 연산자.
 + , - , / , * 과, ^ = 지수,   %% = 나머지 연산자,  %/% = 몫(정수)

관계 연산자.
< , > , <= , >= , == , !=   -> 순서대로 작다, 크다 , 작거나 같다, 크거나 같다, 같다, 다르다.

논리 연산자.
  !  = 논리 NOT
 &  = 엘리먼트 단위 논리 AND
&& = 논리 AND
  |   = 엘리먼트 단위 논리 OR
 ||  = 논리 OR

할당 연산자.
<-  , <<-,  =    : 왼쪽 변수에 할당.
-> , ->>    : 오른쪽 변수에 할당.


3. 중위 연산자.
R 에서 사용하는 대부붑ㄴ의 연산자는 2항 연산자 (2개의 피연산자가 있음)
피연산자간에 사용되는 중위 연산자(infix operator)
이 연산자는 백그라운드에서 함수 호출.
예를 들어, a+b 라는 표현식은 실제로 인자 a와 , 인자 b 를 갖는 ` + `( ) 함수를 호출.
=> ` + ` (a,b)
=> 5+3 = 8.
=> `+`(5,3)

%% = 나머지.
%/% = 몫.
%*% = 행렬의 곱 또는 벡터의 내적.
a <- c(2,3,4)
b <- c(10,20,30)
a %o% b

%o% = 외적.     => outer : 문자열의 모든 쌍별 조합을 만듬.
a <-c('1','2','3')
b <-c('a','b','c')
outer(a,b,FUN=paste)

%x% = 크로네커 곱.
%in% = 매칭 연산자.



4. 함수  = function 은 return.이 필요함.
함수는 코드를 논리적으로 단순한 부분으로 나누어 유지하고 이해하기 쉽게 만든다.
함수정의

func_name <- function (argument) {
statement
}
– 함수를 정의하기 위해 function 예약어를 사용
– 중괄호({ }) 안에 있는 명령문은 함수 본문을 구성
– 함수의 본문이 단일 표현식을 경우에는 중괄호를 생략할 수 있다.
– 함수 객체는 func_name에 할당하여 이름을 부여받는다.
– 예
pOW <- function(x, y) {
result <- x^y
print(paste0(x, "의 ", y, "승은 ", result, "입니다."))
}

4-1 이름을 갖는 인자
함수 호출에서 실제 인수에 대한 형식 인수의 인수 일치는 위치 순서대로 발생
– pOW(2,3)에서 형식 인자 x와 y가 각각 2와 3으로 지정된다는 것을 의미

R에서는 이름이 지정된 인수를 사용하여 함수를 호출 할 수도 있다.
– 실제 인수의 순서는 중요하지 않다.
> pOW(2,3)
[1] "2의 3승은8입니다.“
> pOW(x=2, y=3)
[1] "2의 3승은8입니다.“
> pOW(y=3, x=2)
[1] "2의 3승은8입니다.“
• 명명 된 인수와 명명되지 않은 인수를 사용할 수 있다.
– 모든 명명 된 인수가 먼저 일치 된 다음 나머지 이름이 없는 인수가 위치 순서대로 매치된다.
> pOW(x=2, 3)
[1] "2의 3승은8입니다.“
> pOW(3, x=2)
[1] "2의 3승은8입니다."

4-2 인자의 기본값

인자의 기본값
– R의 함수에서 인수에 기본값을 할당 할 수 있다.
– 함수 선언의 형식 인수에 적절한 값을 제공하여 수행된다.
– 다음 함수는 y에 대한 기본값이 있다.
pOW <- function(x, y=2) {
result <- x^y
print(paste0(x, "의 ", y, "승은 ", result, "입니다."))
}
– 인수에 기본값을 사용하면 함수를 호출 할 때 기본값을 갖는 인수는 선택적이 될 수 있다.
> pOW(3)
[1] "3의 2승은9입니다.“
> pOW(3,3)
[1] "3의 3승은27입니다."

4-3 리턴문
return(expression)
- 함수에서 리턴된 값은 유효한 오브젝트가 될 수 있다.
check <- function(x) {
  if(x > 0) {
    result <- "Positive"
 } else if ( x < 0 ) {
    result <- "Negative"
  }else {
   result <- "Zero"
  }
  return(result)
}

>check(1)
[1]"Positive"
> check(-3)
[1]"Negative"
> check(0)
[1] "Zero"

4-4 return( ) 문이 없는 함수
- 함수에서 명시적으로 반환 값이 없으면 마지막으로 평가 된 표현식의 값이 자동으로 R에 반환.
check <- function(x) {
  if (x > 0) {
   result <- "Positive"
 }else if (x < 0) {
   result <- "Negative"
 } else {
  result <- "Zero"
 }
  result
}

4-5 다중 리턴
– return() 함수는 단일 객체 만 반환 할 수 있다.
–R에 여러 값을 반환하려는 경우 list 객체(또는 다른 객체)를 사용하여 이를 반환 할 수 있다.
multi_return <- function() {
my_list <- list("cOlOr" = "red", "size" = 20, "shape" = "rOund")
return(my_list)
}


5. 가변인자
– 예) mean(x, ...)
– ... 에 의한 추가 인수는 다른 함수로 전달되거나 다른 함수로부터 전달
–인자로 다양한 값을 전달 할 수 있다. a
dd <- function(...) {
args <- list(...) su
m <- 0; fOr(data
in args) {
sum = sum +data;
}
print(sum)
}
– 이 add() 함수는 인자에 몇 개를 전달하더라도 함수는 올바른 결과를 출력.
> add(1,2)
[1] 3
> add(1,2,3)
[1] 6
>add(1,2,3,4)
[1] 10

6. 재귀호출 : 함수내에서 자기함수를 호출하는 함수
rm(list = ls())
fact <- function(num){
  if(num<0){
    return()
  }else if(num==1){
    return(1)
  }else{
    return(num * fact(num-1))
  }
  
}
fact(3)
# fact(3) -> 6(3!)을 리턴하는 걸 만들꺼임.
# fact(3) = 3 * fact(2)
      #  = 3 * 2 * fact(1)
      # = 3 * 2 * 1
#fact(num) = num * fact(num-1) (단, num이 1보다 클 때, fact(1)=1 ) 

7. R 환경(EnvirOnment)
R 환경(EnvirOnment)은 객체 (함수, 변수 등)의 집합
R 인터프리터를 시작할 때 환경이 만들어진다.
R 명령 프롬프트에서 사용할 수 있는 최상위 환경은 R_GlobalEnv라는 글로벌 환경
– 글로벌 환경은 R 코드에서 .GlobalEnv
ls() 함수를 사용하여 현재 환경에서 정의 된 변수 및 함수를 표시
> rm(list=ls())
> a <- 3
> b <- 7
> f <- function(x) x <- 1
> ls()
• [1] "a" "b" "f"


7-1.유효 범위
변수들은 어디에 선언되어 있는지에 따라 다른 유효 범위(ScOpe)를 갖는다.
Outer_func <- function(){
    b <- 20
inner_func <- function(){
    c <- 30
  }
}
a <- 10

전역변수(GlObal Variable)
– 프로그램을 실행하는 동안 존재하는 변수
– 프로그램의 어느 부분에서든지 변경하고 액세스 할 수 있다.
– 그러나 전역 변수는 함수의 관점에도 의존
예를 들어 위의 예에서 inner_func()의 관점에서 a와 b는 모두 전역 변수
그러나 Outer_func()의 관점에서 보면 b는 지역 변수이고 a는 전역 변수다. 
변수 c는 Outer_func() 에서 완전히 보이지 않는다.

지역변수(LoCal Variable)
– 지역 변수(LoCal Variable)는 함수처럼 프로그램의 특정 부분에만 존재하는 변수
– 수 호출이 끝나면 해제
– 변수 c는 지역 변수
– 함수 inner_func()를 사용하여 변수에 값을 할당하면 변경은 로컬 일 뿐이며 함수 외부에서는 액세스 할 수 없다.
– 전역 변수와 지역 변수의 이름이 일치하는 경우에도 동일.




7-2. 값에 의한 호출

R에서 함수 호출방식은 값에 의한 호출
함수 밖에서 선언한 함수를 함수 안에서 바꾸더라도 함수 밖의 변수에는 영향을 주지 않는다.
a <- 10
b <- 20
func <- function(a, b) {
   a <- a+10
   b <- b+10
   return (a+b)
}
우연의 일치 인 것처럼 전역변수와 지역변수의 이름이 같지만 실제 프로그램에서는 전혀 다른 공간에 변수가 만들어지기 때문에 다른 변수 
위 함수를 호출하는 구문이 실행된 다음 함수 밖의 a는 바뀌지 않는다.
다음 코드는 함수를 호출한 후 a 변수의 값을 출력하는 예. 
함수 안에서 a는 20이 되지만 이는 함수 밖의 a변수와는 완전히 다른 변수다.
>func(a,b)
[1] 50
> a
[1]10


7-3. 전역변수에 값 할당

전역 변수를 읽을 수는 있지만 할당하려고 하면 대신 새로운 지역 변수가 생성
전역 변수에 할당하려면 슈퍼 할당 연산자 <<-가 사용된다.

함수 내에서 이 연산자를 사용하면 상위 환경 프레임에서 변수를 검색
– 발견되지 않으면 변수가 전역 환경에 도달 할 때까지 계속해서 다음 상위 레벨을 검색
– 변수가 여전히 발견되지 않으면 변수가 작성되고 전역 레벨로 지정
Outer_func <- function(){
  inner_func <- function(){
   a <<- 30
   print(a)
}
  inner_func()
  print(a)
}
> Outer_func()
[1]30
[1]30
>print(a)
[1] 30

