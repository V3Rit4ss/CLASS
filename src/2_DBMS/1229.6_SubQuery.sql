--[VI]  SUB QUERY : QUERY 안에 QUERY사 내포
-- 1. 서브쿼리 개념.
-- 서브쿼리 =(1)단일행 서브쿼리(서브쿼리 결과가 단일행) =, >, >=, <, <=, <>, !=
--          (2) 다중행 서브쿼리(서브쿼리 결과가 2행이상 일때.) IN, NOT IN, ANY, SOME, ALL, EXISTS

--SCOTT이 근무하는 부서이름 출력
SELECT DNAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='SCOTT';
SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'; --서브 쿼리
SELECT DNAME FROM DEPT WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'); --메인쿼리
--서브쿼리 블럭을 잡고 F9를 누르면 블럭칸만 실행. 이렇게 해서 서브쿼리가 잘 되는지 보고 메인쿼리를 작동시킨다.

--서브쿼리 가 먼저 실행함.'

--JOB 이 MANAGER 인 사람의 부서이름을 출력.
SELECT DEPTNO FROM EMP WHERE JOB='MANAGER'; --다중행 서브쿼리   '=' 단일행 
SELECT DNAME FROM DEPT WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE JOB='MANAGER'); --메인쿼리  'IN' 다중행 연산자

--2. 단일행 서브쿼리.  결과가 오직 하나. (단일행, 단일열.)
--회사에서 급여를 제일 많이 받는사람의 이름과 급여.
SELECT MAX(SAL) FROM EMP; --서브쿼리
SELECT ENAME, SAL FROM EMP WHERE SAL=(SELECT MAX(SAL) FROM EMP); --메인쿼리

--SCOTT과 같은 부서번호인 사람이름.
SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT';--서브쿼리
SELECT ENAME FROM EMP WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT') AND ENAME <> 'SCOTT';--메인쿼리

--SCOTT과 같은 근무지인 사람이름. (50번 DALLAS 부서 홍길동 입력.)

SELECT * FROM EMP;
SELECT * FROM DEPT;
DESC EMP;
INSERT INTO DEPT VALUES (50, 'IT', 'DALLAS');
INSERT INTO EMP (EMPNO, ENAME, DEPTNO) VALUES (9999,'홍',50);
--EMPNO 프라이머리 키 라서 유일한 한가지의 변수.

SELECT LOC FROM DEPT D, EMP E WHERE D.DEPTNO=E.DEPTNO AND ENAME='SCOTT'; --서브쿼리
SELECT ENAME FROM EMP E, DEPT D 
    WHERE E.DEPTNO=D.DEPTNO AND LOC=(SELECT LOC FROM DEPT D, EMP E WHERE D.DEPTNO=E.DEPTNO AND ENAME='SCOTT')
    AND ENAME<> 'SCOTT';

--SCOTT과 같은 부서에 근무하는  사람들의 급여합을 출력
SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'; --서브 쿼리
SELECT SUM(SAL) FROM EMP WHERE DEPTNO=(SELECT DEPTNO FROM EMP WHERE ENAME='SCOTT'); --메인쿼리

--SCOTT과 동일한 JOB 을 가진 사원의 모든 정보를 출력.
SELECT * FROM EMP WHERE JOB=(SELECT JOB FROM EMP WHERE ENAME='SCOTT');

--DALLAS 에서 근무하는 사원의 이름,부서번호 출력 
ROLLBACK; --DML 명령어 취소 (홍 관련 추가한거 취소댐.)
SELECT ENAME, DEPTNO FROM EMP WHERE DEPTNO=(SELECT DEPTNO FROM DEPT WHERE LOC='DALLAS');

--SALES(DNAME) 부서에 근무하는 직원의 이름,급여 출력.
SELECT ENAME, SAL FROM EMP WHERE DEPTNO=(SELECT DEPTNO FROM DEPT WHERE DNAME='SALES');

--KING 이 직속상사인 사원의 이름,급여 출력.
SELECT ENAME, SAL FROM EMP WHERE MGR=(SELECT EMPNO FROM EMP WHERE ENAME='KING' );

--평균급여 이하로 받는 사원의 이름, 급여 출력.
SELECT ENAME, SAL FROM EMP WHERE SAL<=(SELECT AVG(SAL) FROM EMP);

--단일행 다중열.  SCOTT 과 JOB 과 부서번호가 같은 직원의 모든 필드 출력 --서브쿼리와 메인쿼리. 
SELECT * FROM EMP WHERE (JOB,DEPTNO)=(SELECT JOB, DEPTNO FROM EMP WHERE ENAME='SCOTT');
--웨얼 절의 위치와 서브쿼리 의 셀렉트 절 위치가 다르면 안댐.


-- ★ 총 연습문제 파트1
--1. 사원테이블에서 가장 먼저 입사한 사람의 이름, 급여, 입사일
SELECT HIREDATE FROM EMP WHERE HIREDATE LIKE '80%';
SELECT ENAME , SAL ,HIREDATE FROM EMP WHERE HIREDATE =(SELECT HIREDATE FROM EMP WHERE HIREDATE LIKE '80%');

SELECT ENAME, SAL,HIREDATE FROM EMP WHERE HIREDATE = (SELECT MIN(HIREDATE) FROM EMP);

-- 2. 회사에서 가장 급여가 적은 사람의 이름, 급여
SELECT MIN(SAL) FROM EMP;
SELECT ENAME, SAL FROM EMP WHERE SAL = (SELECT MIN(SAL) FROM EMP);

-- 3. 회사 평균보다 급여를 많이 받는 사람의 이름, 급여, 부서코드
SELECT ENAME, SAL, DEPTNO FROM EMP WHERE SAL > (SELECT ROUND(AVG(SAL)) FROM EMP);


--4. 회사 평균 이하의 급여를 받는 사람의 이름, 급여, 부서명
SELECT ENAME, SAL, DNAME FROM EMP E, DEPT D  WHERE E.DEPTNO=D.DEPTNO AND SAL <= (SELECT ROUND(AVG(SAL)) FROM EMP);


--5. SCOTT보다 먼저 입사한 사람의 이름, 급여, 입사일, 급여 등급  --살그라드의 논이퀴조인. SAL>=LOSAL AND SAL<=HISAL
SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT';                                   --SAL BETWEEN LOSAL AND HISAL
SELECT ENAME, SAL ,HIREDATE, GRADE FROM EMP ,SALGRADE 
    WHERE SAL BETWEEN LOSAL AND HISAL AND HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT');


--6. 5번(SCOTT보다 먼저 입사한 사람의 이름, 급여, 입사일, 급여 등급)에 부서명 추가하고 
    --급여가 큰 순 정렬
SELECT DNAME,ENAME, SAL ,HIREDATE , GRADE FROM EMP E, SALGRADE ,DEPT D 
    WHERE E.DEPTNO=D.DEPTNO 
    AND SAL BETWEEN LOSAL AND HISAL 
    AND HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME='SCOTT') ORDER BY SAL DESC;


--7. 사원테이블에서 BLAKE 보다 급여가 많은 사원들의 사번, 이름, 급여를 검색
SELECT SAL FROM EMP WHERE ENAME ='BLAKE';
SELECT EMPNO, ENAME, SAL FROM EMP WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME='BLAKE');


--8. 사원테이블에서 MILLER보다 늦게 입사한 사원의 사번, 이름, 입사일을 검색하시오
SELECT HIREDATE FROM EMP WHERE ENAME = 'MILLER';
SELECT EMPNO, ENAME, HIREDATE FROM EMP WHERE HIREDATE > (SELECT HIREDATE FROM EMP WHERE ENAME = 'MILLER');

--9. 사원테이블에서 사원전체 평균 급여보다 급여가 많은 사원들의 사번, 이름, 급여를 검색
SELECT AVG(SAL) FROM EMP;
SELECT EMPNO,ENAME,SAL FROM EMP WHERE SAL > (SELECT AVG(SAL) FROM EMP);


--10. 사원테이블에서 CLARK와 같은 부서며, 사번이 7698인 직원의 급여보다 
        -- 많은 급여를 받는 사원들의 사번, 이름, 급여 검색
SELECT DEPTNO FROM EMP WHERE ENAME='CLARK';
SELECT SAL FROM EMP WHERE EMPNO=7698;

SELECT EMPNO, ENAME,SAL FROM EMP
    WHERE DEPTNO = (SELECT DEPTNO FROM EMP WHERE ENAME='CLARK')
    AND SAL > (SELECT SAL FROM EMP WHERE EMPNO=7698);

--11.  응용심화. 사원테이블에서 CLARK와 같은 부서명이며, 사번이 7698인 직원의 급여보다 
    --  많은 급여를 받는 사원들의 사번, 이름, 급여 검색
SELECT EMPNO, ENAME,SAL FROM EMP E , DEPT D
    WHERE E.DEPTNO=D.DEPTNO AND DNAME = (SELECT DNAME FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME='CLARK')
    AND SAL > (SELECT SAL FROM EMP WHERE EMPNO=7698);


--12.  사원 테이블에서 BLAKE와 같은 부서에 있는 모든 사원의 이름과 입사일자를 출력하는 SELECT문을 작성하시오.
SELECT DEPTNO FROM EMP WHERE ENAME='BLAKE';
SELECT ENAME, HIREDATE FROM EMP WHERE DEPTNO =(SELECT DEPTNO FROM EMP WHERE ENAME='BLAKE');

--13.  사원 테이블에서 평균 급여 이상을 받는 모든 종업원에 대해서 사원번호와 이름을 출력
        --(단 급여가 많은 순으로 출력하여라.)
SELECT ROUND(AVG(SAL)) FROM EMP;
SELECT EMPNO, ENAME FROM EMP WHERE SAL >= (SELECT ROUND(AVG(SAL)) FROM EMP) ORDER BY SAL DESC;





--3. 다중행 SubQuery. 에서 이용하는 연산자 : IN,ALL ,ANY=SOME, EXISTS 
--(1) IN : 같다.  서브쿼리의 결과중 하나라도 일치하면 참.
--부서별로 입사일이 가장 늦은 사람의 부서번호 ,이름, 입사일.+ 부서번호 출력
SELECT DEPTNO, MAX(HIREDATE) FROM EMP GROUP BY DEPTNO; --서브쿼리
SELECT EMPNO, ENAME,HIREDATE,DEPTNO FROM EMP 
    WHERE (DEPTNO, HIREDATE) IN (SELECT DEPTNO, MAX(HIREDATE) FROM EMP GROUP BY DEPTNO);

--급여가 3000이상 받는 사원이 소속된 부서에서 근무하는 사원들의 모든 정보 --서브쿼리가 다중행.
SELECT * FROM EMP WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE SAL >= 3000);

--(2) ALL
--30번 부서 최대 급여보다 급여를 받는 사람의 정보
SELECT * FROM EMP WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30); --서브쿼리가 단일행.

SELECT * FROM EMP WHERE SAL > ALL (SELECT SAL FROM EMP WHERE DEPTNO=30); --다중행 일때. 모든결과가 참일때.

--(3)ANY=SOME
SELECT * FROM EMP WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO=30); --다중서브쿼리중에 하나만 맞으면 실행댐.

SELECT * FROM EMP WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE DEPTNO=30); --바로 윗 문장과 같음.

--(4)EXISTS : 서브쿼리 결과가 존재하면 참.
--직속 부하가 있는 직원들의 사번, 이름 ,급여
SELECT EMPNO , ENAME, SAL FROM EMP MANAGER WHERE EXISTS (SELECT * FROM EMP WHERE MANAGER.EMPNO=MGR);

SELECT EMPNO , ENAME, SAL FROM EMP M WHERE EXISTS (SELECT * FROM EMP W WHERE M.EMPNO=W.MGR);

--말단 사원의 모든 정보 출력
SELECT * FROM EMP MANAGER WHERE NOT EXISTS (SELECT * FROM EMP WHERE MANAGER.EMPNO=MGR);


--예제 1
--부서별로 가장 급여를 많이 받는 사원의 사번, 이름, 급여, 부서번호
SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO; --다중행 서브쿼리
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP 
    WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);
    
    
--예제 2    
--?	직급(JOB)이 MANAGER인 사람의 속한 부서의 부서 번호와 부서명과 지역을 출력(IN)
SELECT DEPTNO FROM EMP WHERE JOB='MANAGER';
SELECT DEPTNO, DNAME, LOC FROM DEPT WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE JOB = 'MANAGER');

--서브쿼리 를 안쓰고 JOIN 을 쓴 경우.
SELECT E.DEPTNO, DNAME, LOC FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND JOB='MANAGER';


--내가한.
SELECT JOB , LOC FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND JOB='MANAGER';
SELECT E.DEPTNO, DNAME ,LOC FROM EMP E, DEPT D 
    WHERE E.DEPTNO=D.DEPTNO 
    AND (JOB, LOC) IN (SELECT JOB , LOC FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND JOB='MANAGER'); 
    
    
--?	급여 3000이상인 사람들 중 연봉 등급을 나누어서 해당 등급별 최고 급여을 받는 사람들의 사번, 이름, 직업, 입사일, 급여, 급여등급을 출력
SELECT * FROM SALGRADE ; --급여가 3000 이상인 사람이 4~5등급 밖에 없으니.
SELECT GRADE, MAX(SAL) FROM EMP, SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL AND SAL >= 3000 GROUP BY GRADE;-- 다중행 서브쿼리

SELECT EMPNO , ENAME, JOB, HIREDATE, SAL, GRADE FROM EMP ,SALGRADE 
    WHERE SAL BETWEEN LOSAL AND HISAL 
    AND (GRADE , SAL) IN (SELECT GRADE, MAX(SAL) FROM EMP ,SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL AND SAL >= 3000 GROUP BY GRADE); 

--?	응용심화 : 입사일 분기별로 가장 높은 급여을 받는 사람들의 분기, 사번, 이름, JOB, 상사사번, 입사일, 급여, 상여를 출력하세요
SELECT HIREDATE , CEIL (EXTRACT(MONTH FROM HIREDATE)/3) QUARTER FROM EMP ;

SELECT HIREDATE, CEIL (TO_CHAR(HIREDATE, 'MM')/3) QUARTER FROM EMP;

SELECT CEIL(EXTRACT(MONTH FROM HIREDATE)/3) QUARTER, MAX(SAL) FROM EMP;

SELECT CEIL(EXTRACT(MONTH FROM HIREDATE)/3) QUARTER, EMPNO, ENAME, JOB, MGR, HIREDATE , SAL, COMM FROM EMP 
    WHERE (CEIL(EXTRACT (MONTH FROM HIREDATE)/3), SAL) 
    IN (SELECT CEIL(EXTRACT(MONTH FROM HIREDATE)/3), MAX(SAL) FROM EMP GROUP BY CEIL (EXTRACT(MONTH FROM HIREDATE)/3)) ORDER BY QUARTER;
    
    
--?	SALESMAN 모든 사원들 보다 급여를 많이 받는 사원들의 이름과 급여와 직급(담당 업무)를 출력하되 영업 사원은 출력하지 않는다.(ALL이용)
SELECT ENAME, SAL, JOB FROM EMP WHERE SAL > ALL(SELECT SAL FROM EMP WHERE JOB='SALESMAN'); --ALL 이용

SELECT ENAME, SAL, JOB FROM EMP WHERE SAL>(SELECT MAX(SAL) FROM EMP WHERE JOB='SALESMAN'); -- ALL 이용X

--둘다 값은 같음.

--?	SALESMAN 일부 어떤 한 사원보다 급여를 많이 받는 사원들의 이름과 급여와 직급(담당 업무)를 출력하되 영업 사원은 출력(ANY)
SELECT ENAME, SAL, JOB FROM EMP WHERE SAL > ANY (SELECT SAL FROM EMP WHERE JOB='SALESMAN'); -- ANY 이용

SELECT ENAME, SAL, JOB FROM EMP WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE JOB='SALESMAN'); -- ANY 이용X
    
--둘다 같음.    
    
--?	급여가 3000미만인 사람 중에 가장 최근에 입사한 사람의 사원번호와 이름, 급여, 입사일을 출력
SELECT EMPNO, ENAME, SAL ,HIREDATE FROM EMP WHERE HIREDATE = (SELECT MAX(HIREDATE) FROM EMP WHERE SAL < 3000);
	
SELECT EMPNO, ENAME ,SAL ,HIREDATE FROM EMP WHERE HIREDATE >= ALL (SELECT HIREDATE FROM EMP WHERE SAL < 3000);  --ALL 사용    
--?	직급이 ‘SALESMAN’인 사원이 받는 급여의 최소 급여보다 많이 받는 사원들의 이름, 급여, 직급, 부서번호를 출력하되 부서번호가 20번인 사원은 제외한다(ANY 연산자 이용)
SELECT MIN(SAL) FROM EMP WHERE JOB='SALESMAN';
SELECT ENAME, SAL, JOB, DEPTNO FROM EMP WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE JOB='SALESMAN') AND DEPTNO != 20 ; -- ANY 이용 X
   
SELECT ENAME ,SAL ,JOB ,DEPTNO FROM EMP WHERE SAL > ANY (SELECT SAL FROM EMP WHERE JOB='SALESMAN') AND DEPTNO <> 20;    
    


--총 연습문제 파트2


    -- 여기서부터는 다중행서브쿼리, 이전은 단일행서브쿼리



-- 14. 사원 테이블에서 이름에 “T”가 있는 사원이 근무하는 부서에서 근무하는 모든 종업원에 대해
    --사원 번호,이름,급여를 출력하는 SELECT문을 작성하시오. 단 사원번호 순으로 출력하여라.
SELECT DNAME , ENAME FROM EMP E,DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME LIKE '%T%'; 

SELECT EMPNO, ENAME, SAL FROM EMP E, DEPT D 
    WHERE E.DEPTNO=D.DEPTNO 
    AND (DNAME,ENAME) 
    IN (SELECT DNAME , ENAME FROM EMP E,DEPT D WHERE E.DEPTNO=D.DEPTNO AND ENAME LIKE '%T%') ORDER BY EMPNO;

SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE ENAME LIKE '%T%') ORDER BY EMPNO;



-- 15. 사원 테이블에서 부서 위치가 Dallas인 모든 종업원에 대해 이름,업무,급여를 출력
SELECT ENAME, JOB, SAL FROM EMP WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE INITCAP(LOC)='Dallas');

SELECT ENAME , JOB,SAL FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND INITCAP(LOC)='Dallas';

---??

SELECT ENAME ,LOC FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC='DALLAS';

SELECT ENAME,JOB,SAL FROM EMP E , DEPT D WHERE E.DEPTNO=D.DEPTNO 
    AND (ENAME,LOC) IN (SELECT ENAME ,LOC FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC='DALLAS');

SELECT * FROM EMP;
SELECT * FROM DEPT;

-- 16. EMP 테이블에서 King에게 보고하는 모든 사원의 이름과 급여를 출력하는 SELECT문
SELECT ENAME, SAL FROM EMP WHERE MGR=(SELECT EMPNO FROM EMP WHERE INITCAP(ENAME)='King');

SELECT ENAME, SAL FROM EMP W WHERE EXISTS (SELECT * FROM EMP WHERE EMPNO=W.MGR AND INITCAP(ENAME)='King');



SELECT W.ENAME, W.MGR, M.ENAME  FROM EMP W, EMP M WHERE W.MGR=M.EMPNO AND M.ENAME='KING' ;

SELECT W.ENAME, W.SAL FROM EMP W, EMP M WHERE (W.ENAME, W.MGR, M.ENAME) IN (SELECT W.ENAME, W.MGR, M.ENAME  FROM EMP W, EMP M WHERE W.MGR=M.EMPNO AND M.ENAME='KING');





-- 17. 사원 테이블에서 SALES부서 사원의 이름,업무를 출력하는 SELECT문을 작성하시오.
SELECT ENAME, JOB FROM EMP WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE DNAME='SALES');

--JOIN 이용
SELECT ENAME, JOB FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND DNAME='SALES';


SELECT * FROM DEPT;
SELECT * FROM EMP;
SELECT ENAME FROM EMP E,DEPT D WHERE E.DEPTNO=D.DEPTNO AND DNAME='SALES'; --서브쿼리 JOB 을 안넣고 하니까 아닌것처럼 보인거임.
SELECT ENAME, JOB FROM EMP 
    WHERE (ENAME) IN (SELECT ENAME FROM EMP E,DEPT D WHERE E.DEPTNO=D.DEPTNO AND DNAME='SALES'); --메인쿼리


-- 18. 사원 테이블에서 월급이 부서 30의 최저 월급보다 높은 사원을 출력
SELECT * FROM EMP WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE DEPTNO=30);
SELECT * FROM EMP WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO = 30);


SELECT MIN(SAL) FROM EMP WHERE DEPTNO=30;
SELECT ENAME,SAL FROM EMP WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE DEPTNO=30);

SELECT * FROM EMP;

-- 19. 부서 10에서 부서 30의 사원과 같은 업무를 맡고 있는 사원의 이름과 업무를 출력
SELECT ENAME, JOB FROM EMP WHERE DEPTNO=10 AND JOB IN (SELECT JOB FROM EMP WHERE DEPTNO=30);



-- 20. 사원 테이블에서 FORD와 업무도 월급도 같은 사원의 모든 정보를 출력
SELECT JOB,SAL FROM EMP WHERE ENAME='FORD';  
SELECT * FROM EMP WHERE (JOB,SAL) IN (SELECT JOB,SAL FROM EMP WHERE ENAME='FORD') AND ENAME != 'FORD';


-- 21. 이름이 JONES인 직원의 JOB과 같거나 
    --월급이 FORD 월급 이상인 사원의 정보를 이름,업무,부서번호,급여를 출력하는 SELECT문을 작성.
    -- 단, 업무별 알파벳 순, 월급이 많은 순으로 출력하여라.
--필요한거 존의 직업 과 포드의 월급.
SELECT JOB FROM EMP WHERE ENAME ='JONES'; --단일행 서브쿼리
SELECT SAL FROM EMP WHERE ENAME ='FORD';--단일행 서브쿼리

SELECT ENAME, JOB, DEPTNO, SAL FROM EMP WHERE JOB =(SELECT JOB FROM EMP WHERE ENAME='JONES') OR SAL >= (SELECT SAL FROM EMP WHERE ENAME='FORD')
    ORDER BY JOB,SAL DESC;


-- 22. 사원 테이블에서 SCOTT 또는 WARD와 월급이 같은 사원의 정보를 이름,업무,급여를 출력하는 SELECT문을 작성하시오.
SELECT ENAME ,JOB ,SAL FROM EMP WHERE SAL IN (SELECT SAL FROM EMP WHERE ENAME='SCOTT' OR ENAME='WARD') 
    AND ENAME NOT IN ('SCOTT','WARD');

SELECT ENAME, JOB ,SAL FROM EMP WHERE SAL IN (SELECT SAL FROM EMP WHERE ENAME IN ('SCOTT','WARD'))  
    AND ENAME NOT IN ('SCOTT','WARD');



-- 23. 사원 테이블에서 CHICAGO에서 근무하는 사원과 같은 업무를 하는 사원들의 이름,업무를 출력하는 SELECT문을 작성하시오.
SELECT ENAME , JOB FROM EMP WHERE JOB IN (SELECT JOB FROM EMP E, DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC='CHICAGO');

--내가 한.
SELECT  LOC FROM EMP E,DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC='CHICAGO';
SELECT ENAME, JOB FROM EMP E,DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC IN (SELECT LOC FROM EMP E,DEPT D WHERE E.DEPTNO=D.DEPTNO AND LOC='CHICAGO');
SELECT * FROM EMP;
SELECT * FROM DEPT;


-- 24. 사원 테이블에서 부서별로 월급이 평균 월급보다 높은 사원을 사원번호,이름,급여를 출력하는 SELECT문을 작성하시오.
--select deptnom avg(sal) from emp group by deptno; 오답.
--select * from emp;

--셀렉절에도 서브쿼리가 들어갈수있는데 (이 안에 넣어야한다.) 웨얼절에도 프럼절에도 들어갈수있음.
SELECT EMPNO , ENAME, SAL,DEPTNO,(SELECT AVG(SAL) FROM EMP WHERE DEPTNO=E.DEPTNO) FROM EMP E 
    WHERE SAL > (SELECT AVG(SAL) FROM EMP WHERE DEPTNO=E.DEPTNO);


-- 25. 사원 테이블에서 업무별로 월급이 평균 월급보다 낮은 사원을 부서번호,이름,급여를 출력하는 SELECT문을 작성하시오.
--셀렉절에 서브쿼리가 들어감.
SELECT DEPTNO , ENAME , SAL, (SELECT AVG(SAL) FROM EMP WHERE JOB=E.JOB)  FROM EMP E 
    WHERE SAL < (SELECT AVG(SAL) FROM EMP WHERE E.JOB=JOB);


-- 26 사원 테이블에서 적어도 한 명 이상으로부터 보고를 받을 수 있는 사원을 업무,이름,사원번호,부서번호를 출력(단, 부서번호 순으로 오름차순 정렬)
SELECT JOB , ENAME, EMPNO, DEPTNO FROM EMP M WHERE EXISTS (SELECT EMPNO FROM EMP WHERE M.EMPNO=MGR) ORDER BY DEPTNO;

SELECT JOB,ENAME, EMPNO,DEPTNO FROM EMP WHERE EMPNO IN (SELECT MGR FROM EMP) ORDER BY DEPTNO;
--SELECT DISTINCT MGR FROM EMP

-- 27. 사원 테이블에서 말단 사원의 사원번호, 이름, 업무, 부서번호를 출력하는 SELECT문을 작성하시오.
SELECT EMPNO, ENAME, JOB , DEPTNO FROM EMP M WHERE NOT EXISTS (SELECT EMPNO FROM EMP WHERE M.EMPNO=MGR);

SELECT M.EMPNO,M.ENAME, M.JOB, M.DEPTNO FROM EMP W, EMP M WHERE W.MGR(+)=M.EMPNO AND W.ENAME IS NULL;

    
--서브 쿼리 결과가 NULL 이 있어서 아래의 문장은 안댐.
SELECT EMPNO, ENAME, JOB , DEPTNO FROM EMP WHERE EMPNO NOT IN (SELECT MGR FROM EMP);


--그리하여 아래의 문장과 같이 한다.  그래서 MGR의 널값을 뺀다,
SELECT EMPNO, ENAME , JOB, DEPTNO FROM EMP WHERE EMPNO NOT IN (SELECT MGR FROM EMP WHERE MGR IS NOT NULL);