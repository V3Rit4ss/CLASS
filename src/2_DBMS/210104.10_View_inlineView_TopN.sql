--[X] VIEW , INLINE VIEW , TOP-N 구문
--1. VIEW : 가상의 테이블 (1) 단순뷰 , (2)복합뷰

--(1) 단순뷰
CREATE OR REPLACE VIEW EMPv0  --EMPv0 이라는 VIEW가 없으면 만들고 있으면 수정해라. 일부필드를 갖는 가상의 테이블
    AS SELECT EMPNO , ENAME, JOB, DEPTNO FROM EMP;  -- AS 옆에 서브쿼리.

SELECT * FROM EMPv0;   --기존의 테이블처럼 볼수있지만 지정된 것만 보고, 수정 만 할수있다.

INSERT INTO EMPv0 VALUES (1111, '홍', 'IT', 40);  --VIEW 에 INSERT
SELECT * FROM EMPv0;  --INSERT 값이 들어갔는지 확인.
SELECT * FROM EMP;  --EMP 테이블에도 변화 옴.
UPDATE EMPv0 SET JOB= 'ANALYST' WHERE EMPNO= 1111;
DELETE FROM EMPv0 WHERE EMPNO=1111;
--EMPv0 이라는 VIEW = EMP의 30번 부서 행 만 
CREATE OR REPLACE VIEW EMPv0
    AS SELECT * FROM EMP WHERE DEPTNO=30;   --VIEW 는 DDL 이라 ROLLBACK 안댐. 
    
SELECT * FROM USER_VIEWS; --데이터 딕셔너리 뷰 를 확인.
SELECT * FROM EMPv0;  --30번 부서만 넣었으니 30번 부서만 보인다.
DESC EMPv0;  -- 구조도 테이블이랑 같이 나온다.
INSERT INTO EMPv0 VALUES (1111, '홍', NULL,NULL,NULL,NULL,NULL,30);
SELECT * FROM EMPv0;  --상단 INSERT 확인.

INSERT INTO EMPv0 VALUES (1112, '홍', NULL,NULL,NULL,NULL,NULL,40);  --EMP 테이블에서는 보임.
SELECT * FROM EMPv0; --30번 부서만 보이게해서 40번 부서는 보이지가 않는다.
SELECT * FROM EMP;

DELETE FROM EMPv0 WHERE EMPNO<1113; --30번 부섬나 지워짐.
DELETE FROM EMP WHERE EMPNO<1113;
COMMIT;

-- EMP테이블 30번 부서의 가상의 테이블(30번 부서만 INSERT 가능하게 조건을 줌)
CREATE OR REPLACE VIEW EMPv0
    AS SELECT * FROM EMP WHERE DEPTNO=30
    WITH CHECK OPTION; --VIEW 의 제한 조건.   WHERE 절이 있어야 체크 가능,
    
SELECT * FROM EMPv0;
INSERT INTO EMPv0 VALUES (1111, '홍', NULL,NULL,NULL,NULL,NULL,30);
INSERT INTO EMPv0 VALUES (1112, '홍', NULL,NULL,NULL,NULL,NULL,40);   --제한조건 때문에 아래 오류사항이 나온다.
--명령의 38 행에서 시작하는 중 오류 발생 -
--INSERT INTO EMPv0 VALUES (1111, '홍', NULL,NULL,NULL,NULL,NULL,40)
--오류 보고 -
--ORA-01402: view WITH CHECK OPTION where-clause violation

DELETE FROM EMPv0 WHERE EMPNO=1111;  --EMP 테이블에서 삭제가 되기에 롤백 가능.


--(2) 복합뷰
CREATE OR REPLACE VIEW EMPv1
    AS SELECT EMPNO, ENAME , JOB ,DNAME FROM DEPT D, EMP E WHERE D.DEPTNO=E.DEPTNO;  --두 테이블은 조인한 AS서브쿼리 + VIEW 생성.

SELECT * FROM EMPv1;
INSERT INTO EMPv1 VALUES (1111,'홍','SALESMAN','RESEARCH');  --복합뷰는 인서트 불가능.

--복합뷰 포함 DML 명령어를 모두 사용할 수 없는 경우(INSERT,DELETE,UPDATE 불가.)
CREATE OR REPLACE VIEW EMPv2
    AS SELECT EMPNO, ENAME, DEPTNO FROM EMP
    WITH READ ONLY;  --읽기 전용 VIEW [편집 불가, 보기만 가능.]
SELECT * FROM EMPv2;
SELECT EMPNO, ENAME, DNAME FROM EMPv2 E, DEPT D WHERE E.DEPTNO=D.DEPTNO;
INSERT INTO EMPv2 VALUES (1111, '홍',40);  --불가.

--EMP (이름, 급여)
CREATE OR REPLACE VIEW EMPv3
    AS SELECT ENAME, SAL FROM EMP;
SELECT * FROM EMPv3;    --VIEW 에 없는것들은 다 NULL 로 들어간다.
INSERT INTO EMPv3 VALUES ('홍',9000);  --EMPNO 가 프라이머리 키 여서 NOT NULL 이니 인서트가 안된다.   

--EMP (사번,이름,연봉=SAL*12)
--서브쿼리의 필드명에 특수문자가 있을 경우 1.별칭 주기.
CREATE OR REPLACE VIEW EMPv3  --특수문자 안댐. * , () 할려면 별명을 붙혀야함.
    AS SELECT EMPNO, ENAME, SAL*12 YEARSAL FROM EMP;  
--서브쿼리의 필드명에 특수문자가 있을 경우 2. 별칭을 따로 주는법.
CREATE OR REPLACE VIEW EMPv3 (NO, NAME, YEARSAL)  --이렇게 따로 주면 되지만 따로줄꺼면 셀렉절의 모든 별명을 지어주어야함,
    AS SELECT EMPNO,ENAME,SAL*12 FROM EMP;
SELECT * FROM EMPv3;
INSERT INTO EMPv3 VALUES (1115, '홍', 12000); -- VIEW 생성할때 필드에 연산이 있으면 INSERT 불가.

--VIEW 생성시 함수를 사용한 경우( 단일행 ,그룹행 )도 INSERT 불가.
--EMP (사번,이름, 반올림한 SAL)
CREATE OR REPLACE VIEW EMPv3
    AS SELECT EMPNO, ENAME, ROUND(SAL, -2) SAL FROM EMP;
SELECT * FROM EMPv3;
INSERT INTO EMPv3 VALUES (1115, '홍',1000); --함수 포함이여서 인서트 불가.

--부서번호 , 최소급여, 최대급여, 부서평균 을 포함한 DEPTv1 VIEW 생성.
CREATE OR REPLACE VIEW DEPTv1 (DEPTNO, MINSAL, MAXSAL, AVGSAL)
    AS SELECT DEPTNO, MIN(SAL), MAX(SAL), ROUND(AVG(SAL), 1) FROM EMP GROUP BY DEPTNO;
SELECT * FROM DEPTv1;

--부서번호, 부서명, 최소급여, 최대급여, 부서 평균급여   --생성할때의 별명을 가져와서 셀렉트 해라. 
SELECT DEPT.DEPTNO, DNAME, MINSAL, MAXSAL, ROUND(AVGSAL) FROM DEPTv1 , DEPT WHERE DEPTv1.DEPTNO=DEPT.DEPTNO;
DESC DEPTv1;
INSERT INTO DEPTv1 VALUES (40, 700, 9000, 4000);  --함수를 썼기때문에 인서트 불가. 수정도 불가.

SELECT * FROM EMP WHERE EMPNO<1115;
DELETE FROM EMP WHERE EMPNO<1115;
SELECT COUNT (*) FROM EMP;
--EMP(중복이 제거된 JOB, DEPTNO )
SELECT DISTINCT JOB, DEPTNO FROM EMP ORDER BY JOB; --서브쿼리 순서를 준거는 그저 원하는걸 찾기 쉽게 할려고 넣은거라 안넣어도 무방.
CREATE OR REPLACE VIEW EMPv3
    AS SELECT DISTINCT JOB, DEPTNO FROM EMP ORDER BY JOB;
SELECT * FROM EMPv3;
INSERT INTO EMPv3 VALUES ('CLERK',10);  --DISTINCT 포함한 VIEW 라서 인서트 불가.


--2. INLINE VIEW : SQL문 수행하는 한줄의 명령어에서만 유용한 뷰   한행 수행할때 잠깐 생성되는 뷰.
--FROM 절의 서브쿼리 = INLINE VIEW 라 한다.
-- SELECT 필드1, 필드2 ~
-- FROM EMP E, (서브쿼리) "S"
-- WHERE 조건

--급여가 2000을 초과하는 사원의 평균급여
SELECT AVG(SAL) FROM EMP WHERE SAL > 2000;
SELECT AVG(SAL) FROM (SELECT SAL FROM EMP WHERE SAL > 2000); --프럼절 수행후 이름없는 가상의 뷰가 만들어진다.

--이름 ,급여,부서번호, 해당사원의 부서평균 급여. 셀렉절에 서브쿼리.
SELECT ENAME, SAL, DEPTNO, (SELECT AVG(SAL) FROM EMP WHERE DEPTNO=E.DEPTNO) FROM EMP E;

--상위의 문제와 같은 내용의 INLINE VIEW 사용 프럼절에 서브쿼리.
SELECT ENAME, SAL ,DEPTNO FROM EMP;  -- [ 1 ]
SELECT DEPTNO, ROUND(AVG(SAL)) FROM EMP GROUP BY DEPTNO; -- [ 2 ]
-- 1번과 2번 의 합.
SELECT ENAME, SAL,E.DEPTNO, S.AVGSAL FROM EMP "E" , (SELECT DEPTNO, ROUND(AVG(SAL)) "AVGSAL" FROM EMP GROUP BY DEPTNO) "S"
    WHERE E.DEPTNO=S.DEPTNO;   --INLINE VIEW 에 별칭 무조건 해줘야함.

--이름, 급여, 부서번호, 해당사원의 부서평균(부서평균보다 많이 받는 직원만)
SELECT ENAME, SAL ,E.DEPTNO, ROUND(AVGSAL) FROM EMP E ,(SELECT DEPTNO, AVG(SAL) AVGSAL FROM EMP GROUP BY DEPTNO) "S"
    WHERE E.DEPTNO=S.DEPTNO AND SAL>AVGSAL;

--3. TOP - N 구문  (TOP - 1~10등, TOP - 11~20등 TOP - 6~10등  ... )  INLINE VIEW 개념이 들어간다.
--ROWNUM : EMP테이블에서 가져온 순서. => 테이블에서 행의 논리적인 출력 순서.
SELECT ROWNUM, ENAME, SAL FROM EMP;
SELECT ROWNUM, ENAME, SAL FROM EMP ORDER BY SAL; --프럼 EMP 에서 셀렉절에 맞게 가져온다음. ORDER BY SAL 로 순서 배치.
SELECT ROWNUM, ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL);
SELECT ROWNUM ,ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL) WHERE ROWNUM < 6; --TOP 1~ 5 까지출력
SELECT ROWNUM ,ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL) WHERE ROWNUM >=6 AND ROWNUM<=10; --TOP 6~10 까지
--BETWEEN 6 AND 10 --BETWEEN 이던 위처럼 하던 안나옴.  TOP -N 구문 미완성이라 그럼.

--함수를 이용한 RANK 출력.
SELECT RANK() OVER(ORDER BY SAL) RANK,
    DENSE_RANK() OVER (ORDER BY SAL) "D_RANK",
    ROW_NUMBER() OVER (ORDER BY SAL) N_RNAK, ENAME, SAL FROM EMP;

-- TOP - N 구문
SELECT ROWNUM , ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL)
    WHERE ROWNUM BETWEEN 1 AND 5;  --6~10 등 불가함. 그래서 아래에서 수정할려고함.
SELECT ROWNUM, RN, ENAME , SAL FROM (SELECT ROWNUM RN, ENAME, SAL FROM (SELECT * FROM EMP ORDER BY SAL ))
    WHERE RN BETWEEN 6 AND 10;  --서브쿼리안에서 등수와 순서를 정해지고 서브쿼리 RN가 셀렉절 RN 으로 들어간다.
    -- THIS IS REAL   TOP - N 구문.

--이름 알파벳 순서대로 6~10등까지 출력 (이름, 사번, JOB, MGR, HIREDATE)
SELECT ROWNUM RN , ENAME , EMPNO, JOB ,MGR , HIREDATE FROM (SELECT * FROM EMP ORDER BY ENAME ); --서브쿼리

SELECT ENAME , EMPNO, JOB , MGR , HIREDATE 
    FROM (SELECT ROWNUM RN , ENAME , EMPNO, JOB ,MGR , HIREDATE FROM (SELECT * FROM EMP ORDER BY ENAME ))
    WHERE RN BETWEEN 6 AND 10;
--FROM (SELECT ROWNUM RN , ENAME , EMPNO, JOB ,MGR , HIREDATE = * 로 해도되고 * 않할꺼면 제시한 조건대로 넣자.


--<총 연습문제>
-- 1. 부서명과 사원명을 출력하는 용도의 뷰, DNAME_ENAME_VU 를 작성하시오
CREATE OR REPLACE VIEW DNAME_ENAME_VU
    AS SELECT DNAME, ENAME FROM EMP E ,DEPT D WHERE E.DEPTNO=D.DEPTNO;
SELECT * FROM DNAME_ENAME_VU;

-- 2. 사원명과 직속상관명을 출력하는 용도의 뷰,  WORKER_MANAGER_VU를 작성하시오
CREATE OR REPLACE VIEW WORKER_MANAGER_VU  --셀렉절에 ENAME 중복 OR 특수문자 때문에 별칭 지어주자.
    AS SELECT W.ENAME "WORKER" , M.ENAME "MANAGER" FROM EMP W, EMP M WHERE W.MGR=M.EMPNO;
SELECT * FROM WORKER_MANAGER_VU;


-- 3. 부서별 급여합계 등수를 출력하시오(부서번호, 급여합계, 등수) ? 친구출제

SELECT DEPTNO, SUM(SAL) "SUMSAL" FROM EMP GROUP BY DEPTNO ORDER BY SUM(SAL) DESC; --서브

SELECT ROWNUM "등수",DEPTNO, SUMSAL FROM (SELECT DEPTNO, SUM(SAL) "SUMSAL" FROM EMP GROUP BY DEPTNO ORDER BY SUM(SAL) DESC);

-- 3-1. 부서별 급여합계 등수가 2~3등인 부서번호, 급여합계, 등수를 출력하시오.
SELECT RN "등수", DEPTNO , SUMSAL 
    FROM (SELECT ROWNUM RN, DEPTNO, SUMSAL FROM(SELECT DEPTNO, SUM(SAL) "SUMSAL" FROM EMP GROUP BY DEPTNO ORDER BY SUM(SAL) DESC))
    WHERE RN BETWEEN 2 AND 3;

-- 4. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 순으로 정렬하시오
SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC;

-- 5. 사원테이블에서 사번, 사원명, 입사일을 입사일이 최신에서 오래된 사원 5명을 출력하시오
SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC; --서브쿼리
SELECT EMPNO, ENAME, HIREDATE 
    FROM (SELECT EMPNO, ENAME, HIREDATE FROM EMP ORDER BY HIREDATE DESC)
    WHERE ROWNUM <= 5;
    
-- 6. 사원 테이블에서 사번, 사원명, 입사일을 최신부터 오래된 순으로 6번째로 늦은 사원부터 10번째 사원까지 

SELECT EMPNO, ENAME, HIREDATE 
    FROM (SELECT ROWNUM RN, EMPNO, ENAME, HIREDATE FROM (SELECT * FROM EMP ORDER BY HIREDATE DESC)) WHERE RN BETWEEN 6 AND 10;


